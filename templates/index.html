{{ define "content" }}
<a href="/" style="text-decoration: none; color: inherit;"></a>
<div id="myBtnContainer">
<a class="medium">{{.Title}}</a><a class="small">{{ .User }} </a><a class="small">Total users: {{ .Count }}</a> <a class="small"> Users online: {{ .Online }} </a>
</div>
<p class="lead">
  <a href="/thread/new">Start a thread</a> or join one below!
</p>
<form method="post" action="/">
  <select name="selection1">
    <option value="">None</option>
    <option value="Sports">Sports</option>
    <option value="Movies">Movies</option>
    <option value="Games">Games</option>
    <option value="Other">Other</option>
  </select>
  <select name="selection2">
    <option value="">None</option>
    <option value="Sports">Sports</option>
    <option value="Movies">Movies</option>
    <option value="Games">Games</option>
    <option value="Other">Other</option>
  </select>
  <button type="submit" class="btn btn-primary">Filter</button>
  <a href="/" class="btn btn-secondary">Show All</a>
</form>
<!-- <div class="container1"> -->
{{ range .Threads }}

<div class="filterDiv {{ .Category1 }} {{ .Category2 }}">
  {{ .Category1 }}{{ if and .Category1 .Category2 }}, {{ end }}{{ .Category2 }}
  <br>
  <div class="card shadow-sm mb-3" style="border-bottom: solid 2px black;">
    <div class="card-header bg-light text-break d-flex justify-content-between">
      <span class="lead"><i class="fa fa-comments-o"> {{ .Topic }}</i></span>
    </div>
    <div class="d-flex justify-content-between align-items-center me-2 p-2">
      <div class="small">Started by <a class="medium" href="/account?user_id={{.UserId}}">{{ .User.Name }}</a> - {{ .CreatedAtDate }} - {{ .NumReplies }} posts.</div>
      <!-- <div class=""> -->
        <!-- </div> -->
        <div class="pull-right justify-content-between">
          <button class="btn py-1 px-1 btn-sm btn-success like-btn" data-thread-id="{{ .Id }}" onclick="likeThread('{{ .Id }}')">
            <i class="fa fa-thumbs-up"></i> <span id="likes-{{ .Id }}">{{ .LikesCount }}</span>
          </button>
          <button class="btn py-1 px-1 btn-sm btn-danger dislike-btn" data-thread-id="{{ .Id }}" onclick="dislikeThread('{{ .Id }}')">
            <i class="fa fa-thumbs-down"></i> <span id="dislikes-{{ .Id }}">{{ .DislikesCount }}</span>
          </button>
          <a href="/thread/read?id={{.Id }}">Read more</a>
        </div>
      </div>
    </div>
  </div>
<!-- </div> -->
{{ end }}
</div>
<script>
  // Like/Dislike functionality with vote-once logic
  function likeThread(threadId) {
    console.log('Like button clicked for thread:', threadId);
    const likeBtn = document.querySelector(`button[onclick="likeThread(${threadId})"]`);
    const dislikeBtn = document.querySelector(`button[onclick="dislikeThread(${threadId})"]`);
    
    if (likeBtn) {
      likeBtn.disabled = true;
    }
    if (dislikeBtn) {
      dislikeBtn.disabled = true;
    }
    // TODO: fetch all thredsIds that can find, and ask server for data for them all at once, instead of one by one
    // This will reduce number of requests and speed up initial load
    // Then updateVoteDisplay for each threadId with the data received
    // For now, keep it simple and do one by one
    // Future optimization: batch requests for multiple thread IDs
    // Future optimization: debounce clicks to prevent multiple rapid requests
    // Future optimization: show loading spinner on buttons while request is in progress
    // Future optimization: handle network errors gracefully
    // Future optimization: cache vote status in localStorage to reduce server load
    // Future optimization: use WebSocket for real-time updates if multiple users are voting simultaneously
    // Future optimization: add animations to button state changes

    // TODO: sending .IsAuthenticated to html to avoid 401 errors
    // so we can fetch without errors if not authorised
    fetch('/api/thread/' + threadId + '/like', {
      method: 'POST',
      credentials: 'same-origin' // Include cookies
    })
    .then(response => {
      console.log('Like response status:', response.status);
      if (response.status === 401) {
        alert('Please log in to like threads.');
        // throw new Error('Unauthorized - Please log in');
      }
      if (!response.ok) {
        // throw new Error('Network response was not ok');
      }
      return response.json();
    })
    .then(data => {
      console.log('Like response data:', data);
      if (data) {
        updateVoteDisplay(threadId, data);
      }
    })
    .catch(error => {
      console.log('=== LIKE ERROR CAUGHT ===');
      console.log('Error object:', error);
      console.log('Error name:', error.name);
      console.log('Error message:', error.message);
      console.log('Error constructor:', error.constructor.name);
      // console.error('Error processing like:', error);
      if (error.message.includes('Unauthorized')) {
        // Already showed alert in response handler, just log
        console.log('User is not authorized - login required');
      } else if (error.message.includes('401')) {
        alert('Please log in to like threads.');
      } else if (error.message.includes('404')) {
        alert('Thread not found.');
      } else if (error.message.includes('Network response was not ok')) {
        alert('Server error. Please try again later.');
      } else {
        console.log('Generic error caught in like function:');
        console.log('Error type:', typeof error);
        console.log('Error message:', error.message);
        console.log('Error stack:', error.stack);
        console.log('Full error object:', error);
        alert('Error processing like. Please make sure you are logged in and try again.');
      }
    })
    .finally(() => {
      // Re-enable buttons
      if (likeBtn) {
        likeBtn.disabled = false;
      }
      if (dislikeBtn) {
        dislikeBtn.disabled = false;
      }
    });
  }

  function dislikeThread(threadId) {
    console.log('Dislike button clicked for thread:', threadId);
    const likeBtn = document.querySelector(`button[onclick="likeThread(${threadId})"]`);
    const dislikeBtn = document.querySelector(`button[onclick="dislikeThread(${threadId})"]`);

    if (likeBtn) {
      likeBtn.disabled = true;
    }
    if (dislikeBtn) {
      dislikeBtn.disabled = true;
    }

    fetch('/api/thread/' + threadId + '/dislike', {
      method: 'POST',
      credentials: 'same-origin' // Include cookies
    })
    .then(response => {
      console.log('Dislike response status:', response.status);
      if (response.status === 401) {
        alert('Please log in to dislike threads.');
        // throw new Error('Unauthorized - Please log in');
      }
      if (!response.ok) {
        // throw new Error('Network response was not ok');
      }
      return response.json();
    })
    .then(data => {
      console.log('Dislike response data:', data);
      if (data) {
        updateVoteDisplay(threadId, data);
      }
    })
    .catch(error => {
      console.log('=== DISLIKE ERROR CAUGHT ===');
      console.log('Error object:', error);
      console.log('Error name:', error.name);
      console.log('Error message:', error.message);
      console.log('Error constructor:', error.constructor.name);
      // console.error('Error processing dislike:', error);
      if (error.message.includes('Unauthorized')) {
        // Already showed alert in response handler, just log
        console.log('User is not authorized - login required');
      } else if (error.message.includes('401')) {
        alert('Please log in to dislike threads.');
      } else if (error.message.includes('404')) {
        alert('Thread not found.');
      } else if (error.message.includes('Network response was not ok')) {
        alert('Server error. Please try again later.');
      } else {
        console.log('Generic error caught in dislike function:');
        console.log('Error type:', typeof error);
        console.log('Error message:', error.message);
        console.log('Error stack:', error.stack);
        console.log('Full error object:', error);
        alert('Error processing dislike. Please make sure you are logged in and try again.');
      }
    })
    .finally(() => {
      // Re-enable buttons
      if (likeBtn) {
        likeBtn.disabled = false;
      }
      if (dislikeBtn) {
        dislikeBtn.disabled = false;
      }
    });
  }

  // Update vote display based on server response
  function updateVoteDisplay(threadId, data) {
    console.log('updateVoteDisplay called for thread:', threadId, 'with data:', data);
    
    // Try multiple ways to find the buttons
    let likeBtn = document.querySelector(`button[onclick="likeThread(${threadId})"]`);
    let dislikeBtn = document.querySelector(`button[onclick="dislikeThread(${threadId})"]`);
    
    // Fallback: try using data-thread-id attribute
    if (!likeBtn) {
      likeBtn = document.querySelector(`button[data-thread-id="${threadId}"].like-btn`);
    }
    if (!dislikeBtn) {
      dislikeBtn = document.querySelector(`button[data-thread-id="${threadId}"].dislike-btn`);
    }
    
    // console.log('Found like button:', likeBtn);
    // console.log('Found dislike button:', dislikeBtn);
    
    // Check if elements exist before trying to update them
    if (!likeBtn || !dislikeBtn) {
      // console.error('Could not find buttons for thread', threadId);
      console.log('Available buttons with data-thread-id:', document.querySelectorAll('[data-thread-id="' + threadId + '"]'));
      console.log('All like buttons:', document.querySelectorAll('.like-btn'));
      console.log('All dislike buttons:', document.querySelectorAll('.dislike-btn'));
      return;
    }
    
    // Update counts - check if count elements exist
    const likesElement = document.getElementById('likes-' + threadId);
    const dislikesElement = document.getElementById('dislikes-' + threadId);
    
    if (likesElement) {
      likesElement.textContent = data.likes;
    } else {
      // console.error('Could not find likes element for thread', threadId);
    }
    
    if (dislikesElement) {
      dislikesElement.textContent = data.dislikes;
    } else {
      // console.error('Could not find dislikes element for thread', threadId);
    }
    
    // Update visual state based on user's vote
    if (data.userLiked) {
      likeBtn.classList.add('voted');
      dislikeBtn.classList.remove('voted');
    } else if (data.userDisliked) {
      dislikeBtn.classList.add('voted');
      likeBtn.classList.remove('voted');
    } else {
      // User has no vote
      likeBtn.classList.remove('voted');
      dislikeBtn.classList.remove('voted');
    }
    
    console.log('Vote display updated successfully for thread', threadId);
  }

  // Load initial vote status for all threads when page loads
  function loadInitialVoteStatus() {
    const threadIds = Array.from(document.querySelectorAll('[data-thread-id]')).map(el => el.dataset.threadId);
    
    threadIds.forEach(threadId => {
      fetch('/api/thread/' + threadId + '/status', {
        credentials: 'same-origin'
      })
      .then(response => {
        if (!response.ok) {
          // throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return response.json();
      })
      .then(data => {
        updateVoteDisplay(threadId, data);
      })
      .catch(error => {
        // console.error('Error loading vote status for thread ' + threadId + ':', error);
        // Don't show alert for initial load errors - just log them
      });
    });
  }

  // Load vote status when page is ready
  document.addEventListener('DOMContentLoaded', function() {
    loadInitialVoteStatus();
  });
  </script>
{{ end }}

