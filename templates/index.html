{{ define "content" }}
<div id="myBtnContainer">
  <button class="btn active" onclick="filterSelection('all')">Show all</button>
  <button class="btn" onclick="filterSelection('Sports')">Sports</button>
  <button class="btn" onclick="filterSelection('Movies')">Movies</button>
  <button class="btn" onclick="filterSelection('Games')">Games</button>
  <button class="btn" onclick="filterSelection('Other')">Other</button>
</div>
<p class="lead">
  <a href="/thread/new">Start a thread</a> or join one below!
</p>

<div class="container1">
{{ range . }}

<div class="filterDiv {{ .Category }}">
  {{ .Category }}
  <br>
  <div class="card shadow-sm mb-3" style="border-bottom: solid 2px black;">
    <div class="card-header bg-light text-break d-flex justify-content-between">
      <span class="lead"><i class="fa fa-comments-o"> {{ .Topic }}</i></span>
    </div>
    <div class="card-body p-2">
      <div class="small">Started by <a class="medium" href="/account?user_id={{.UserId}}">{{ .User.Name }}</a> - {{ .CreatedAtDate }} - {{ .NumReplies }} posts.</div>
      <!-- <div class=""> -->
        <!-- </div> -->
        <div class="pull-right justify-content-between">
          <button class="btn py-1 px-1 btn-sm btn-success like-btn" data-thread-id="{{ .Id }}" onclick="likeThread('{{ .Id }}')">
            <i class="fa fa-thumbs-up"></i> <span id="likes-{{ .Id }}">{{ .LikesCount }}</span>
          </button>
          <button class="btn py-1 px-1 btn-sm btn-danger dislike-btn" data-thread-id="{{ .Id }}" onclick="dislikeThread('{{ .Id }}')">
            <i class="fa fa-thumbs-down"></i> <span id="dislikes-{{ .Id }}">{{ .DislikesCount }}</span>
          </button>
          <a href="/thread/read?id={{.Id }}">Read more</a>
        </div>
      </div>
    </div>
  </div>
</div>
{{ end }}
</div>
<script>
  filterSelection("all")
  function filterSelection(c) {
    var x, i;
    x = document.getElementsByClassName("filterDiv");
    if (c == "all") c = "";
    for (i = 0; i < x.length; i++) {
      w3RemoveClass(x[i], "show");
      if (x[i].className.indexOf(c) > -1) w3AddClass(x[i], "show");
    }
  }
  
  function w3AddClass(element, name) {
    var i, arr1, arr2;
    arr1 = element.className.split(" ");
    arr2 = name.split(" ");
    for (i = 0; i < arr2.length; i++) {
      if (arr1.indexOf(arr2[i]) == -1) {element.className += " " + arr2[i];}
    }
  }
  
  function w3RemoveClass(element, name) {
    var i, arr1, arr2;
    arr1 = element.className.split(" ");
    arr2 = name.split(" ");
    for (i = 0; i < arr2.length; i++) {
      while (arr1.indexOf(arr2[i]) > -1) {
        arr1.splice(arr1.indexOf(arr2[i]), 1);     
      }
    }
    element.className = arr1.join(" ");
  }
  
  // Add active class to the current button (highlight it)
  var btnContainer = document.getElementById("myBtnContainer");
  var btns = btnContainer.getElementsByClassName("btn");
  for (var i = 0; i < btns.length; i++) {
    btns[i].addEventListener("click", function(){
      var current = document.getElementsByClassName("active");
      current[0].className = current[0].className.replace(" active", "");
      this.className += " active";
    });
  }

  // Like/Dislike functionality with vote-once logic
  function likeThread(threadId) {
    console.log('Like button clicked for thread:', threadId);
    const likeBtn = document.querySelector(`button[onclick="likeThread(${threadId})"]`);
    const dislikeBtn = document.querySelector(`button[onclick="dislikeThread(${threadId})"]`);
    
    if (likeBtn) {
      likeBtn.disabled = true;
    }
    if (dislikeBtn) {
      dislikeBtn.disabled = true;
    }
    // TODO: fetch all thredsIds that can find, and ask server for data for them all at once, instead of one by one
    // This will reduce number of requests and speed up initial load
    // Then updateVoteDisplay for each threadId with the data received
    // For now, keep it simple and do one by one
    // Future optimization: batch requests for multiple thread IDs
    // Future optimization: debounce clicks to prevent multiple rapid requests
    // Future optimization: show loading spinner on buttons while request is in progress
    // Future optimization: handle network errors gracefully
    // Future optimization: cache vote status in localStorage to reduce server load
    // Future optimization: use WebSocket for real-time updates if multiple users are voting simultaneously
    // Future optimization: add animations to button state changes

    // TODO: sending .IsAuthenticated to html to avoid 401 errors
    // so we can fetch without errors if not authorised
    fetch('/api/thread/' + threadId + '/like', {
      method: 'POST',
      credentials: 'same-origin' // Include cookies
    })
    .then(response => {
      console.log('Like response status:', response.status);
      if (response.status === 401) {
        alert('Please log in to like threads.');
        // throw new Error('Unauthorized - Please log in');
      }
      if (!response.ok) {
        // throw new Error('Network response was not ok');
      }
      return response.json();
    })
    .then(data => {
      console.log('Like response data:', data);
      if (data) {
        updateVoteDisplay(threadId, data);
      }
    })
    .catch(error => {
      console.log('=== LIKE ERROR CAUGHT ===');
      console.log('Error object:', error);
      console.log('Error name:', error.name);
      console.log('Error message:', error.message);
      console.log('Error constructor:', error.constructor.name);
      // console.error('Error processing like:', error);
      if (error.message.includes('Unauthorized')) {
        // Already showed alert in response handler, just log
        console.log('User is not authorized - login required');
      } else if (error.message.includes('401')) {
        alert('Please log in to like threads.');
      } else if (error.message.includes('404')) {
        alert('Thread not found.');
      } else if (error.message.includes('Network response was not ok')) {
        alert('Server error. Please try again later.');
      } else {
        console.log('Generic error caught in like function:');
        console.log('Error type:', typeof error);
        console.log('Error message:', error.message);
        console.log('Error stack:', error.stack);
        console.log('Full error object:', error);
        alert('Error processing like. Please make sure you are logged in and try again.');
      }
    })
    .finally(() => {
      // Re-enable buttons
      if (likeBtn) {
        likeBtn.disabled = false;
      }
      if (dislikeBtn) {
        dislikeBtn.disabled = false;
      }
    });
  }

  function dislikeThread(threadId) {
    console.log('Dislike button clicked for thread:', threadId);
    const likeBtn = document.querySelector(`button[onclick="likeThread(${threadId})"]`);
    const dislikeBtn = document.querySelector(`button[onclick="dislikeThread(${threadId})"]`);

    if (likeBtn) {
      likeBtn.disabled = true;
    }
    if (dislikeBtn) {
      dislikeBtn.disabled = true;
    }

    fetch('/api/thread/' + threadId + '/dislike', {
      method: 'POST',
      credentials: 'same-origin' // Include cookies
    })
    .then(response => {
      console.log('Dislike response status:', response.status);
      if (response.status === 401) {
        alert('Please log in to dislike threads.');
        // throw new Error('Unauthorized - Please log in');
      }
      if (!response.ok) {
        // throw new Error('Network response was not ok');
      }
      return response.json();
    })
    .then(data => {
      console.log('Dislike response data:', data);
      if (data) {
        updateVoteDisplay(threadId, data);
      }
    })
    .catch(error => {
      console.log('=== DISLIKE ERROR CAUGHT ===');
      console.log('Error object:', error);
      console.log('Error name:', error.name);
      console.log('Error message:', error.message);
      console.log('Error constructor:', error.constructor.name);
      // console.error('Error processing dislike:', error);
      if (error.message.includes('Unauthorized')) {
        // Already showed alert in response handler, just log
        console.log('User is not authorized - login required');
      } else if (error.message.includes('401')) {
        alert('Please log in to dislike threads.');
      } else if (error.message.includes('404')) {
        alert('Thread not found.');
      } else if (error.message.includes('Network response was not ok')) {
        alert('Server error. Please try again later.');
      } else {
        console.log('Generic error caught in dislike function:');
        console.log('Error type:', typeof error);
        console.log('Error message:', error.message);
        console.log('Error stack:', error.stack);
        console.log('Full error object:', error);
        alert('Error processing dislike. Please make sure you are logged in and try again.');
      }
    })
    .finally(() => {
      // Re-enable buttons
      if (likeBtn) {
        likeBtn.disabled = false;
      }
      if (dislikeBtn) {
        dislikeBtn.disabled = false;
      }
    });
  }

  // Update vote display based on server response
  function updateVoteDisplay(threadId, data) {
    console.log('updateVoteDisplay called for thread:', threadId, 'with data:', data);
    
    // Try multiple ways to find the buttons
    let likeBtn = document.querySelector(`button[onclick="likeThread(${threadId})"]`);
    let dislikeBtn = document.querySelector(`button[onclick="dislikeThread(${threadId})"]`);
    
    // Fallback: try using data-thread-id attribute
    if (!likeBtn) {
      likeBtn = document.querySelector(`button[data-thread-id="${threadId}"].like-btn`);
    }
    if (!dislikeBtn) {
      dislikeBtn = document.querySelector(`button[data-thread-id="${threadId}"].dislike-btn`);
    }
    
    // console.log('Found like button:', likeBtn);
    // console.log('Found dislike button:', dislikeBtn);
    
    // Check if elements exist before trying to update them
    if (!likeBtn || !dislikeBtn) {
      // console.error('Could not find buttons for thread', threadId);
      console.log('Available buttons with data-thread-id:', document.querySelectorAll('[data-thread-id="' + threadId + '"]'));
      console.log('All like buttons:', document.querySelectorAll('.like-btn'));
      console.log('All dislike buttons:', document.querySelectorAll('.dislike-btn'));
      return;
    }
    
    // Update counts - check if count elements exist
    const likesElement = document.getElementById('likes-' + threadId);
    const dislikesElement = document.getElementById('dislikes-' + threadId);
    
    if (likesElement) {
      likesElement.textContent = data.likes;
    } else {
      // console.error('Could not find likes element for thread', threadId);
    }
    
    if (dislikesElement) {
      dislikesElement.textContent = data.dislikes;
    } else {
      // console.error('Could not find dislikes element for thread', threadId);
    }
    
    // Update visual state based on user's vote
    if (data.userLiked) {
      likeBtn.classList.add('voted');
      dislikeBtn.classList.remove('voted');
    } else if (data.userDisliked) {
      dislikeBtn.classList.add('voted');
      likeBtn.classList.remove('voted');
    } else {
      // User has no vote
      likeBtn.classList.remove('voted');
      dislikeBtn.classList.remove('voted');
    }
    
    console.log('Vote display updated successfully for thread', threadId);
  }

  // Load initial vote status for all threads when page loads
  function loadInitialVoteStatus() {
    const threadIds = Array.from(document.querySelectorAll('[data-thread-id]')).map(el => el.dataset.threadId);
    
    threadIds.forEach(threadId => {
      fetch('/api/thread/' + threadId + '/status', {
        credentials: 'same-origin'
      })
      .then(response => {
        if (!response.ok) {
          // throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return response.json();
      })
      .then(data => {
        updateVoteDisplay(threadId, data);
      })
      .catch(error => {
        // console.error('Error loading vote status for thread ' + threadId + ':', error);
        // Don't show alert for initial load errors - just log them
      });
    });
  }

  // Load vote status when page is ready
  document.addEventListener('DOMContentLoaded', function() {
    loadInitialVoteStatus();
  });
  </script>
{{ end }}

